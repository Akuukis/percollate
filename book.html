<!DOCTYPE html>
<html class="type--html">
	<head>
		<meta charset="utf-8" />
		<title>My Book</title>

		<style type="text/css">
			:root {
				--main-font: Palatino, 'Palatino Linotype', 'Times New Roman',
					'Droid Serif', Times, 'Source Serif Pro', serif,
					'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
				--alt-font: 'helvetica neue', ubuntu, roboto, noto, 'segoe ui',
					arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji',
					'Segoe UI Symbol';
				--code-font: Menlo, Consolas, monospace;
				--accent-color: black;
			}

			@page {
				size: A5 portrait;
				margin: 1cm 1cm 2cm;
			}

			html {
				font-size: 12pt;
				line-height: 1.3;
				font-family: var(--main-font);
				-webkit-print-color-adjust: exact;
			}

			h1,
			h2,
			h3,
			h4,
			h5,
			h6 {
				margin-bottom: 0.5em;
				font-family: var(--alt-font);
				font-weight: bold;
				page-break-after: avoid;
			}

			a {
				color: inherit;
				text-decoration: underline;
			}

			/*
	Going on a limb here,
	but a.anchor in heading elements
	is most likely a '#' or '§' anchor
	we don't want to display in the PDF.
 */
			h1 a.anchor,
			h2 a.anchor,
			h3 a.anchor,
			h4 a.anchor,
			h5 a.anchor,
			h6 a.anchor {
				display: none;
			}

			th {
				font-family: var(--alt-font);
			}

			code,
			pre {
				font-size: 0.85em;
			}

			pre code {
				font-size: 1em;
			}

			/*
	Don't display hidden elements
 */
			[hidden],
			[aria-hidden] {
				display: none;
			}

			/*
	Table of Contents page
	----------------------------------------------------
 */

			.toc {
				page-break-after: always;
			}

			/*
	Article formatting
	----------------------------------------------------
 */

			article {
				font-size: 1em;
			}

			article:not(:last-of-type) {
				page-break-after: always;
			}

			/*
	Article Header
	--------------
 */

			.article__header {
				margin: 0 0 1.3em;
			}

			.article__title {
				font-size: 2.4em;
				margin: 0 0 0.25em;
				letter-spacing: -0.03em;
				line-height: 1.1;
			}

			.article__url {
				font-style: italic;
				font-size: 0.9em;
			}

			/*
	Article Content
	---------------
 */

			.article__content img {
				max-width: 100%;
				display: block;
				margin: 0 auto;
			}

			.article__content figure {
				display: block;
				margin: 1.5em 0;
				padding: 0;
				text-align: center;
			}

			.article__content figcaption {
				font-size: 0.8em;
				font-family: var(--alt-font);
				margin: 0.81em 0;
				line-height: 1.625;
			}

			.article__content figure blockquote {
				text-align: left;
			}

			.article__content table,
			.article__content figure {
				page-break-inside: avoid;
			}

			.article__content pre,
			.article__content code {
				font-family: var(--code-font);
			}

			.article__content pre {
				border: 0.25pt solid #000;
				padding: 0.75em;
				font-size: 0.9em;
				white-space: pre-wrap;
				word-wrap: break-word;
			}

			.article__content kbd,
			.article__content var,
			.article__content samp {
				padding: 0 0.5em;
				box-shadow: 2pt 2pt 0 #ccc;
				border: 0.5pt solid #000;
				border-radius: 0.25em;
				font-size: 0.9em;
			}

			.article__content p {
				margin: 0;
				orphans: 3;
				widows: 3;
			}

			/*
	Indent all subsequent paragraphs.
 */
			.article__content p + p {
				text-indent: 2em;
			}

			/*
	Fixes the text indent for images
	that get wrapped in a <p> tag
	by Readability.

	Reference:
	https://github.com/danburzo/percollate/issues/48
 */
			.article__content p + p > img:only-child {
				margin-left: -2em;
			}

			.article__content hr {
				border: none;
				height: 0.5pt;
				margin: 1.3em 0;
				background: #000;
			}

			.article__content blockquote {
				font-size: 0.9em;
				line-height: 1.44;
				padding-left: 2em;
				border-left: 3pt solid #000;
				margin-left: 0;
			}

			.article__content table {
				width: 100%;
				border-collapse: collapse;
				page-break-inside: auto;
				font-size: 0.9em;
				line-height: 1.44;
				margin: 1.44em 0;
			}

			.article__content th {
			}

			.article__content th,
			.article__content td {
				text-align: left;
				vertical-align: top;
				padding: 0.36em 1em 0.36em 0;
			}

			.article__content tr {
				border-bottom: 0.25pt solid #000;
				page-break-inside: avoid;
				page-break-after: auto;
			}

			.article__content dt {
				font-weight: bold;
			}

			.article__content ol,
			.article__content ul {
				padding-left: 2em;
				list-style-position: outside;
				margin: 0.65em 0;
			}

			.article__content aside {
				font-family: var(--alt-font);
				font-size: 0.9em;
				line-height: 1.44;
				padding-left: 2em;
			}

			.article__content details {
				margin: 0.65em 0;
			}

			.article__content details > summary {
				font-weight: bold;
				font-size: 0.9em;
				font-family: var(--alt-font);
			}

			/*
	Filetype specific
	-----------------
 */

			.type--pdf body {
				margin: 0;
				padding: 0;
			}

			.type--pdf a:not(.no-href):after {
				content: ' → ' attr(href) '';
				font-size: 0.8em;
				word-break: break-all;
				word-wrap: break-word;
				font-family: var(--alt-font);
			}

			/*
	Page header / footer
	--------------------

	These are extracted when generating the PDF
	and are not subject to the page's CSS cascade.

	They're just placed here for easier style coordination
 */

			.header-template {
			}

			.footer-template {
				font-size: 10pt;
				font-weight: bold;
			}

			/*
	Cover page
	----------
 */

			.cover {
				color: var(--accent-color);
				border: 0.5em solid;
				font-family: var(--cover-font, var(--alt-font));
				padding: 2em;
			}

			@media print {
				.cover {
					position: absolute;
					top: 0;
					left: 0;
					right: 0;
					bottom: 0;
					overflow: hidden;
				}

				.cover__content {
					position: absolute;
					top: 30%;
					left: 2em;
					right: 2em;
					transform: translate(0, -50%);
				}
			}

			.cover__title {
				font-size: 2.4em;
				margin: 0;
				line-height: 1.1;
			}

			.cover__subtitle {
				margin: 1em 0;
			}

			.cover__date {
				font-weight: bold;
			}

			.cover__sentinel {
				page-break-after: always;
			}
		</style>
	</head>
	<body>
		<div class="cover">
			<div class="cover__content">
				<h1 class="cover__title">My Book</h1>
				<p class="cover__subtitle">
					<time class="cover__date" datetime="2020-07-29"
						>2020-07-29</time
					>
				</p>
			</div>
		</div>
		<div class="cover__sentinel">&nbsp;</div>

		<article
			id="percollate-page-738c5d20-d1a1-11ea-b76f-abedfd008a40"
			class="article"
		>
			<header class="article__header">
				<h1 class="article__title">
					Drawing every street in Romania · Dan Cătălin Burzo
				</h1>

				<p class="article__url">
					Source:
					<a class="no-href" href="http://danburzo.ro/every-street"
						>http://danburzo.ro/every-street</a
					>
				</p>
			</header>

			<div class="article__content">
				<div id="readability-page-1" class="page">
					<div>
						<p>
							Ben Fry’s project
							<a
								href="http://3rdfloor.fathom.info/products/all-streets"
								>All Streets</a
							>
							left quite the impression on me back in 2007 and
							it’s stayed in the back of my head ever since. About
							a year ago I started to wonder if I could pull off
							something similar with tools I am comfortable with,
							namely JavaScript for data processing and SVG for
							drawing things.
						</p>
						<p>And this happened:</p>
						<figure>
							<img
								src="http://danburzo.ro.s3-website-us-east-1.amazonaws.com/assets/img/streets.jpg"
							/>
						</figure>
						<p>Here’s a step-by-step account of how I got there.</p>
						<hr />
						<h2 id="1-get-the-data">1. Get the data</h2>
						<p>
							Geofabrik thoughtfully packages
							<a href="http://download.geofabrik.de/europe.html"
								>OpenStreetMap data</a
							>
							for every country, so I grabbed the
							<code>.osm.pbf</code> for Romania.
							<a
								href="http://wiki.openstreetmap.org/wiki/PBF_Format"
								>PBF</a
							>
							is an alternative to the XML format in which OSM
							data is usually kept.
						</p>
						<p>OSM works with just three data types:</p>
						<ul>
							<li>
								<strong>nodes</strong> define points in space
								(through latitude &amp; longitude);
							</li>
							<li>
								<strong>ways</strong> are collections of
								<em>nodes</em> which define linear features
								(yay, streets!) and area boundaries;
							</li>
							<li>
								<strong>relations</strong> are sometimes used to
								explain how other elements work together – e.g.
								multiple ways that define a longer route.
							</li>
						</ul>
						<p>For our modest purposes, we only need:</p>
						<ol>
							<li>Ways that are labeled as <em>streets</em>;</li>
							<li>The nodes that comprise those ways.</li>
						</ol>

						<p>
							Time to brush off our Node.js skills and extract the
							data from the PBF file.
						</p>
						<p>
							After a naïve attempt at loading everything in
							memory, it became apparent that data at this volume
							needs
							<a
								href="https://github.com/substack/stream-handbook"
								>streaming</a
							>
							– a technique in which we read data item-by-item,
							with only fraction in memory at any given time.
							<a href="https://github.com/substack/osm-pbf-parser"
								><code>osm-pbf-parser</code></a
							>
							is a streaming parser which goes through the PBF
							data and outputs small sets of JSON objects in the
							formats below.
						</p>
						<p><strong>This is a node…</strong></p>
						<pre><code>{
  type: <span>'node'</span>,
  id: <span>122321</span>,
  lat: <span>53.527972600000005</span>,
  lon: <span>10.0241143</span>,
  tags: {<span>...</span>},
  info: {<span>...</span>}
}
</code></pre>
						<p><strong>…and this is a way</strong></p>
						<pre><code>{
  <span>type</span>: <span>'way'</span>,
  <span>id</span>: <span>108</span>,
  <span>tags</span>: {
    <span>created_by</span>: <span>'Potlatch 0.8'</span>,
    <span>highway</span>: <span>'living_street'</span>,
    <span>name</span>: <span>'Kitzbühler Straße'</span>,
    <span>postal_code</span>: <span>'01217'</span> 
  },
  <span>refs</span>: <span>[ 442752, 231712390, 442754 ]</span>,
  <span>info</span>: {...}
}
</code></pre>
						<p>
							Traversing the PBF file, we can do these checks to
							pick up the items we need:
						</p>
						<pre><code>  <span><span>function</span> <span>isNode</span><span>(item)</span></span> {
    <span>return</span> item.<span>type</span> === <span>'node'</span>;
  }

  <span><span>function</span> <span>isStreet</span><span>(item)</span></span> {
    <span>return</span> item.<span>type</span> === <span>'way'</span> &amp;&amp; item.tags.highway;
  }
</code></pre>
						<p>
							We’ll put our extracted nodes and streets into
							plain-text files, with one item per line – this is a
							format that’s amenable to streaming so it will be
							easy to read them back on subsequent steps.
						</p>
						<p><strong>extract-nodes.js</strong></p>
						<pre><code><span>var</span> fs = <span>require</span>(<span>'fs'</span>);
<span>var</span> through2 = <span>require</span>(<span>'through2'</span>);
<span>var</span> osm_parser = <span>require</span>(<span>'osm-pbf-parser'</span>);
<span>var</span> JSONStream = <span>require</span>(<span>'JSONStream'</span>);

<span>var</span> INPUT_FILE = <span>'data/data.osm.pbf'</span>;
<span>var</span> OUTPUT_FILE = <span>'output/nodes.txt'</span>;

<span><span>function</span> <span>isNode</span><span>(item)</span> </span>{
    <span>return</span> item.type === <span>'node'</span>;
}

<span><span>function</span> <span>serializeNode</span><span>(item)</span> </span>{
    <span>return</span> item.id + <span>','</span> + item.lat + <span>','</span> + item.lon;
};

<span>console</span>.log(<span>'Extracting nodes from data file: '</span> + INPUT_FILE);
fs.createReadStream(INPUT_FILE)
    .pipe(<span>new</span> osm_parser())
    .pipe(
        through2.obj(<span><span>function</span><span>(items, enc, next)</span> </span>{
            <span>var</span> nodes = items.filter(isNode);
            <span>var</span> output = nodes.map(serializeNode).join(<span>'\n'</span>);
            <span>this</span>.push(output);
            next();
        })
    )
    .pipe(
        fs.createWriteStream(OUTPUT_FILE)
    )
    .on(<span>'finish'</span>, <span><span>function</span><span>()</span> </span>{
        <span>console</span>.log(<span>'Finished extracting nodes onto file: '</span> + OUTPUT_FILE);
    });
</code></pre>
						<p><strong>extract-streets.js</strong></p>
						<pre><code><span>var</span> fs = <span>require</span>(<span>'fs'</span>);
<span>var</span> through2 = <span>require</span>(<span>'through2'</span>);
<span>var</span> osm_parser = <span>require</span>(<span>'osm-pbf-parser'</span>);
<span>var</span> JSONStream = <span>require</span>(<span>'JSONStream'</span>);

<span>var</span> INPUT_FILE = <span>'data/data.osm.pbf'</span>;
<span>var</span> OUTPUT_FILE = <span>'output/streets.txt'</span>;

<span><span>function</span> <span>isStreet</span><span>(item)</span> </span>{
    <span>return</span> item.type === <span>'way'</span> &amp;&amp; item.tags.highway;
}

<span><span>function</span> <span>serializeStreet</span><span>(item)</span> </span>{
    <span>return</span> item.refs.join(<span>','</span>);
}

<span>console</span>.log(<span>'Extracting streets from data file: '</span> + INPUT_FILE);
fs.createReadStream(INPUT_FILE)
    .pipe(<span>new</span> osm_parser())
    .pipe(
        through2.obj(<span><span>function</span><span>(items, enc, next)</span> </span>{
            <span>var</span> streets = items.filter(isStreet);
            <span>var</span> output = streets.map(serializeStreet).join(<span>'\n'</span>);
            <span>this</span>.push(output);
            next();
        })
    )
    .pipe(
        fs.createWriteStream(OUTPUT_FILE)
    ).on(<span>'finish'</span>, <span><span>function</span><span>()</span> </span>{
        <span>console</span>.log(<span>'Finished extracting streets onto file: '</span> + OUTPUT_FILE);
    });
</code></pre>
						<p>Which outputs:</p>
						<p><strong>nodes.txt</strong></p>
						<pre><code><span>360714</span>,<span>44.493699500000005</span>,<span>26.0854494</span>
<span>360853</span>,<span>44.467436600000006</span>,<span>26.0771428</span>
<span>537912</span>,<span>44.425765000000006</span>,<span>26.123137900000003</span>
<span>546140</span>,<span>44.47436450000001</span>,<span>26.123994300000003</span>
<span>...</span>
</code></pre>
						<p>(<code>id,latitude,longitude</code>)</p>
						<p><strong>streets.txt</strong></p>
						<pre><code><span>656951</span>,<span>2260664460</span>,<span>3227352565</span>,<span>656952</span>, <span>...</span>
<span>256700851</span>,<span>2152136723</span>,<span>659642</span>,<span>256705252</span>,<span>2152144026</span>, <span>...</span>
<span>304797001</span>,<span>2382014755</span>,<span>310215524</span>,<span>255848765</span> <span>...</span>
</code></pre>
						<p>(<code>node1,node2,node3,...</code>)</p>
						<p>
							<em>Note:</em> We’re using
							<a href="https://github.com/rvagg/through2"
								><code>through2.obj()</code></a
							>
							to simplify the pipework.
						</p>
						<h2 id="3-mapping-node-ids-to-their-coordinates">
							3. Mapping node IDs to their coordinates
						</h2>
						<p>
							We now have a huge set of node coordinates and
							another huge set of node IDs. In order to map the
							IDs to the coordinates, we need to do two things:
						</p>
						<ol>
							<li>Load the nodes into some sort of database</li>
							<li>
								Query the database to look up the coordinates
								for a given ID
							</li>
						</ol>
						<p>
							For storage I’ve turned to
							<a href="http://leveldb.org/">LevelDB</a> which is a
							pretty straightforward, file-based database. You use
							it in Node through
							<a href="https://github.com/Level/leveldown"
								>leveldown</a
							>
							and
							<a href="https://github.com/Level/levelup"
								>levelup</a
							>.
						</p>
						<p><strong>load-nodes.js</strong></p>
						<pre><code><span>var</span> fs = <span>require</span>(<span>'fs'</span>);
<span>var</span> through2 = <span>require</span>(<span>'through2'</span>);
<span>var</span> split2 = <span>require</span>(<span>'split2'</span>);
<span>var</span> levelup = <span>require</span>(<span>'level'</span>);

<span>var</span> DATABASE_NAME = <span>'everystreet'</span>;
<span>var</span> INPUT_FILE = <span>'output/nodes.txt'</span>;

<span>var</span> i = <span>0</span>;

<span>console</span>.log(<span>'creating levelDB database '</span> + DATABASE_NAME);
levelup(DATABASE_NAME, <span><span>function</span><span>(err, db)</span> </span>{
    <span>var</span> write_stream = db.createWriteStream();
    fs.createReadStream(INPUT_FILE, { encoding: <span>'utf8'</span> })
        .pipe(split2())
        .pipe(through2.obj(<span><span>function</span><span>(line, enc, next)</span></span>{
            <span>var</span> parts = line.split(<span>','</span>);
            <span>this</span>.push({ 
                key: parts[<span>0</span>], 
                value: parts[<span>1</span>] + <span>","</span> + parts[<span>2</span>]
            });

            
            
            <span>if</span> (i++ &gt; <span>999</span>) {
                setImmediate(next);
                i = <span>0</span>;
            } <span>else</span> {
                next();
            }
        }))
        .pipe(write_stream)
        .on(<span>'finish'</span>, <span><span>function</span><span>()</span> </span>{
            <span>console</span>.log(<span>'Finished importing nodes into the database '</span> + DATABASE_NAME);
        });
});
</code></pre>
						<p>
							This creates a LevelDB database with the name
							<code>everystreet</code> (which in turn creates an
							<code>everystreet</code> folder where the data is
							kept), and adds all nodes with
							<code>key=ID</code> and <code>value=lat,lon</code>.
						</p>
						<p>
							<em>Note:</em> While attempting this I
							<a
								href="https://github.com/rvagg/node-levelup/issues/298"
								>ran into some memory troubles</a
							>
							to which the easy solution is to delay every 1000th
							<code>next()</code> call. There’s also
							<a
								href="https://github.com/maxogden/level-bulk-load"
								><code>level-bulk-load</code></a
							>
							which attempts to optimize bulk writing in LevelDB,
							so that might be something to look into.
						</p>
						<p>
							Next, let’s map the node IDs to their coordinates in
							our street definitions.
						</p>
						<p><strong>apply-nodes.js</strong></p>
						<pre><code><span>var</span> fs = <span>require</span>(<span>'fs'</span>);
<span>var</span> through2 = <span>require</span>(<span>'through2'</span>);
<span>var</span> split2 = <span>require</span>(<span>'split2'</span>);
<span>var</span> levelup = <span>require</span>(<span>'level'</span>);
<span>var</span> async = <span>require</span>(<span>'async'</span>);

<span>var</span> DATABASE_NAME = <span>'everystreet'</span>;
<span>var</span> INPUT_FILE = <span>'output/streets.txt'</span>;
<span>var</span> OUTPUT_FILE = <span>'output/streets-with-coordinates.txt'</span>;

<span>console</span>.log(<span>'Applying node data from database '</span> + DATABASE_NAME + <span>' to street data from file: '</span> + INPUT_FILE);
levelup(DATABASE_NAME, <span><span>function</span><span>(err, db)</span> </span>{

    <span>var</span> write_stream = fs.createWriteStream(OUTPUT_FILE);

    fs.createReadStream(INPUT_FILE, { encoding: <span>'utf8'</span> })
        .pipe(split2())
        .pipe(through2.obj(<span><span>function</span><span>(line, enc, next)</span></span>{
            async.mapSeries(line.split(<span>','</span>), <span><span>function</span><span>(node_id, callback)</span> </span>{
                db.get(node_id, <span><span>function</span><span>(err, coords)</span> </span>{
                    callback(err, coords);
                });
            }, <span><span>function</span><span>(err, result)</span> </span>{
                <span>this</span>.push(result.join(<span>','</span>) + <span>'\n'</span>);
                next();
            }.bind(<span>this</span>));
        }))
        .pipe(write_stream)
        .on(<span>'finish'</span>, <span><span>function</span><span>()</span> </span>{
            <span>console</span>.log(<span>'Finished applying node data into file: '</span> + OUTPUT_FILE);
        });
});
</code></pre>
						<p>
							We’re streaming through each street in the data
							file, querying the database for the coordonates –
							using
							<a
								href="http://promise-nuggets.github.io/articles/15-map-in-series.html"
								><code>async.mapSeries</code></a
							>
							to make sure we get back the node data in the
							correct order – and serializing them into a
							plain-text file.
						</p>
						<p><strong>streets-with-coordinates.js</strong></p>
						<pre><code><span>44.469672200000005</span>,<span>26.093109000000002</span>,<span>44.469469600000004</span>,<span>26.093366600000003</span>,<span>...</span>
<span>44.46975080000001</span>,<span>26.092981700000003</span>,<span>44.4696756</span>,<span>26.092841000000004</span>,<span>...</span>
</code></pre>
						<p>
							At this point we’re done with extracting all the
							data we need but we still need to convert it from
							geographical coordinates to screen coordinates.
							<em>*Takes deep breath*</em>. Onwards!
						</p>
						<h2
							id="4-mapping-geographical-coordintes-to-screen-coordinates"
						>
							4. Mapping geographical coordintes to screen
							coordinates
						</h2>
						<p>
							There are many
							<a href="http://bl.ocks.org/mbostock/3711652"
								>different ways to project the Earth’s
								surface</a
							>
							onto 2D space. Many maps are laid out based on the
							<a
								href="http://wiki.openstreetmap.org/wiki/Mercator"
								>spherical Mercator projection</a
							>. Assuming <code>λ</code> is the longitude and
							<code>φ</code> is the latitude, both expressed in
							radians, the formula is simple:
						</p>
						<pre><code><span><span>function</span> <span>mercator</span><span>(λ, φ)</span> </span>{
  <span>return</span> [λ, <span>Math</span>.log(<span>Math</span>.tan(<span>Math</span>.PI/<span>4</span> + φ/<span>2</span>))];
}
</code></pre>
						<p>
							Before we dive into it, let’s see what we need to
							do:
						</p>
						<ol>
							<li>
								Find the <em>bounding box</em> of all our
								coordinates and its aspect ratio;
							</li>
							<li>
								Transform the geographical coordinates into
								screen coordinates, based on the bounding box.
							</li>
						</ol>
						<p>
							The <em>bounding box</em> of our map is the smallest
							rectangle that contains all the nodes. We can find
							it by identifying the minimum/maximum longitude and
							latitude in our dataset. If we transform the points
							that define the bounding box using the Mercator
							projection, we can also obtain our final map’s
							<em>aspect ratio</em>, which we’re going to use
							later. The script below computes both:
						</p>
						<p><strong>bbox.js</strong></p>
						<pre><code><span>var</span> fs = <span>require</span>(<span>'fs'</span>);
<span>var</span> through2 = <span>require</span>(<span>'through2'</span>);
<span>var</span> split2 = <span>require</span>(<span>'split2'</span>);

<span>var</span> INPUT_FILE = <span>'output/streets-with-coordinates.txt'</span>;
<span>var</span> OUTPUT_FILE = <span>'output/bbox.json'</span>;


<span>var</span> bbox = {
    north: -<span>90</span>, 
    south: <span>90</span>, 
    east: -<span>180</span>, 
    west: <span>180</span> 
};

<span><span>function</span> <span>toRadians</span><span>(deg)</span> </span>{
    <span>return</span> deg * <span>Math</span>.PI / <span>180</span>;
}

<span><span>function</span> <span>mercator</span><span>(λ, φ)</span> </span>{
  <span>return</span> [λ, <span>Math</span>.log(<span>Math</span>.tan(<span>Math</span>.PI/<span>4</span> + φ/<span>2</span>))];
}

<span><span>function</span> <span>projection</span><span>(lat, lon)</span> </span>{
    <span>return</span> mercator(toRadians(lon), toRadians(lat));
}

<span>console</span>.log(<span>'Finding bounding box in file: '</span> + INPUT_FILE);
fs.createReadStream(INPUT_FILE, { encoding: <span>'utf8'</span> })
    .pipe(split2())
    .pipe(through2.obj(<span><span>function</span><span>(line, enc, next)</span> </span>{
        <span>var</span> coords = line.split(<span>','</span>);
        <span>for</span> (<span>var</span> j = <span>0</span>; j &lt; coords.length; j+=<span>2</span>) {
            <span>var</span> lat = <span>parseFloat</span>(coords[j]),
                lon = <span>parseFloat</span>(coords[j+<span>1</span>]);

            <span>if</span> (lat &gt; bbox.north) {
                bbox.north = lat;
            }
            <span>if</span> (lat &lt; bbox.south) {
                bbox.south = lat;
            }
            <span>if</span> (lon &gt; bbox.east) {
                bbox.east = lon;
            }
            <span>if</span> (lon &lt; bbox.west) {
                bbox.west = lon;
            }
        }
        next();
    }))
    .on(<span>'finish'</span>, <span><span>function</span><span>()</span> </span>{

        <span>var</span> nw_projected = projection(bbox.north, bbox.west);
        <span>var</span> se_projected = projection(bbox.south, bbox.east);

        <span>var</span> west = nw_projected[<span>0</span>];
        <span>var</span> north = nw_projected[<span>1</span>];
        <span>var</span> east = se_projected[<span>0</span>];
        <span>var</span> south = se_projected[<span>1</span>]; 

        <span>var</span> output = {
            bbox: bbox,
            ratio: (east - west) / (north - south)
        };

        fs.writeFile(OUTPUT_FILE, <span>JSON</span>.stringify(output, <span>null</span>, <span>2</span>));
    });
</code></pre>
						<p>The script outputs the following information:</p>
						<p><strong>bbox.json</strong></p>
						<pre><code>{
  "<span>bbox</span>": <span>{
    "<span>north</span>": <span><span>48.4394855</span></span>,
    "<span>south</span>": <span><span>43.578847700000004</span></span>,
    "<span>east</span>": <span><span>29.726612400000004</span></span>,
    "<span>west</span>": <span><span>20.198656500000002</span>
  </span>}</span>,
  "<span>ratio</span>": <span><span>1.3601773494902782</span>
</span>}
</code></pre>
						<p>
							Let’s now take our geographical coordinates
							transform them using the Mercator projection;
							afterwards, we express them as percentages within
							the map’s bounding box which will make it easy for
							us to draw at any scale.
						</p>
						<p><strong>map-coordinates.js</strong></p>
						<pre><code><span>var</span> fs = <span>require</span>(<span>'fs'</span>);
<span>var</span> through2 = <span>require</span>(<span>'through2'</span>);
<span>var</span> split2 = <span>require</span>(<span>'split2'</span>);

<span>var</span> INPUT_FILE = <span>'output/streets-with-coordinates.txt'</span>;
<span>var</span> OUTPUT_FILE = <span>'output/streets-with-coordinates-mapped.txt'</span>;
<span>var</span> BBOX_FILE = <span>'output/bbox.json'</span>;


<span>var</span> o = <span>JSON</span>.parse(fs.readFileSync(BBOX_FILE, <span>'utf8'</span>));
<span>var</span> nw_projected = projection(o.bbox.north, o.bbox.west);
<span>var</span> se_projected = projection(o.bbox.south, o.bbox.east);
<span>var</span> north = nw_projected[<span>1</span>];
<span>var</span> south = se_projected[<span>1</span>];
<span>var</span> west = nw_projected[<span>0</span>];
<span>var</span> east = se_projected[<span>0</span>];

<span><span>function</span> <span>toRadians</span><span>(deg)</span> </span>{
    <span>return</span> deg * <span>Math</span>.PI / <span>180</span>;
}

<span><span>function</span> <span>mercator</span><span>(λ, φ)</span> </span>{
  <span>return</span> [λ, <span>Math</span>.log(<span>Math</span>.tan(<span>Math</span>.PI/<span>4</span> + φ/<span>2</span>))];
}

<span><span>function</span> <span>projection</span><span>(lat, lon)</span> </span>{
    <span>return</span> mercator(toRadians(lon), toRadians(lat));
}

<span><span>function</span> <span>percent</span><span>(lonlat)</span> </span>{
    <span>return</span> [
        (lonlat[<span>0</span>] - west) / (east - west),
        (lonlat[<span>1</span>] - south) / (north - south)
    ];
}

<span>console</span>.log(<span>'Mapping nodes using Mercador projection from file: '</span> + INPUT_FILE);
fs.createReadStream(INPUT_FILE, { encoding: <span>'utf8'</span> })
    .pipe(split2())
    .pipe(through2.obj(<span><span>function</span><span>(line, enc, next)</span> </span>{
        <span>var</span> coords = line.split(<span>','</span>);
        <span>var</span> pts = [];
        <span>for</span> (<span>var</span> i = <span>0</span>; i &lt; coords.length; i+=<span>2</span>) {
            pts.push(
                percent(
                    projection(coords[i], coords[i+<span>1</span>])
                ).join(<span>','</span>)
            );
        }
        <span>this</span>.push(pts.join(<span>';'</span>) + <span>'\n'</span>);
        next();
    }))
    .pipe(fs.createWriteStream(OUTPUT_FILE))
    .on(<span>'finish'</span>, <span><span>function</span><span>()</span> </span>{
        <span>console</span>.log(<span>'Finished mapping nodes using Mercator projection onto file: '</span> + OUTPUT_FILE);
    });
</code></pre>
						<p>
							All nodes should be now in the
							<code>[0,1]</code> range:
						</p>
						<p>
							<strong>strets-with-coordinates-mapped.txt</strong>
						</p>
						<pre><code><span>0.6186481719547</span>,<span>0.17686588159630384</span>;<span>0.6186752081839509</span>,<span>0.17682535252522288</span>;<span>...</span>
<span>0.618634811271534</span>,<span>0.1768816051533656</span>;<span>0.6186200442006669</span>,<span>0.17686656174973386</span>;<span>...</span>
<span>...</span>
</code></pre>
						<h2 id="5-drawing-the-map-in-svg">
							5. Drawing the map in SVG
						</h2>
						<p>
							We now have everything we need to start drawing some
							SVG paths. This is the structure we’re aiming for:
						</p>
						<pre><code>&lt;svg width=<span>'...'</span> height=<span>'...'</span> viewbox=<span>'...'</span>&gt;
    &lt;path d=<span>"M x1 y1 L x2 y2 L x3 y3 ..."</span>/&gt;
    <span>...</span>
&lt;/svg&gt;
</code></pre>
						<p>
							Remember the <em>map ratio</em> we computed earlier?
							We can use that to derive the height of our map
							based on a width of our choice. And to transform our
							points from the <code>[0,1]</code> range to
							SVG-ready coordinates, we just need to factor in the
							map’s dimensions:
						</p>
						<pre><code><span>var</span> map_width = <span>1500</span>; 
<span>var</span> map_height = map_width / map_ratio; 

<span>var</span> screen_x = longitude * map_width;
<span>var</span> screen_y = (<span>1</span> - latitude) * map_height;
</code></pre>
						<p>
							<em>Note:</em> The <code>1 - latitude</code> is to
							account for the fact that the origin of SVG
							coordinates is at the <em>top left</em> corner while
							our coordinates assume an origin in the
							<em>bottom left</em> corner.
						</p>
						<p><strong>generate-svg.js</strong></p>
						<pre><code><span>var</span> fs = <span>require</span>(<span>'fs'</span>);
<span>var</span> through2 = <span>require</span>(<span>'through2'</span>);
<span>var</span> split2 = <span>require</span>(<span>'split2'</span>);
<span>var</span> multiline = <span>require</span>(<span>'multiline'</span>);

<span>var</span> DEFAULT_MAP_WIDTH = <span>1500</span>; 

<span>var</span> INPUT_FILE = <span>'output/streets-with-coordinates-mapped.txt'</span>;
<span>var</span> OUTPUT_FILE = <span>'output/streets.svg'</span>;
<span>var</span> BBOX_FILE = <span>'output/bbox.json'</span>;

<span>var</span> o = <span>JSON</span>.parse(fs.readFileSync(BBOX_FILE, <span>'utf8'</span>));

<span>var</span> map_width = DEFAULT_MAP_WIDTH;
<span>var</span> map_height = map_width / o.ratio;

<span>var</span> write_stream = fs.createWriteStream(OUTPUT_FILE);

write_stream.write(
    <span>"&lt;svg xmlns='http://www.w3.org/2000/svg' width='{w}' height='{h}' viewbox='0 0 {w} {h}'&gt;"</span>
        .replace(<span>/\{w\}/g</span>, map_width)
        .replace(<span>/\{h\}/g</span>, map_height)
);

<span>console</span>.log(<span>'Generating SVG from file: '</span> + INPUT_FILE);
fs.createReadStream(INPUT_FILE, { encoding: <span>'utf8'</span> })
    .pipe(split2())
    .pipe(through2.obj(<span><span>function</span><span>(line, enc, next)</span> </span>{
        <span>var</span> path_data = <span>'M '</span> + line.split(<span>';'</span>).map(<span><span>function</span><span>(pt)</span> </span>{
            <span>var</span> lonlat = pt.split(<span>','</span>);
            <span>return</span> [lonlat[<span>0</span>] * map_width, (<span>1</span> - lonlat[<span>1</span>]) * map_height].join(<span>' '</span>);
        }).join(<span>' L '</span>);
        <span>this</span>.push(<span>'&lt;path d="'</span> + path_data + <span>'" stroke-width="0.1" stroke="black" fill="none"/&gt;\n'</span>);
        next();
    }, <span><span>function</span><span>(flush)</span> </span>{
        <span>this</span>.push(<span>'&lt;/svg&gt;'</span>);
        flush();
    }))
    .pipe(write_stream)
    .on(<span>'finish'</span>, <span><span>function</span><span>()</span> </span>{
        <span>console</span>.log(<span>'Finished generating SVG onto file: '</span> + OUTPUT_FILE);
    });
</code></pre>
						<p>
							And voilá! We have our all streets in Romania drawn
							up in SVG, which you can open in your browser (<a
								href="http://benfry.com/writing/archives/62"
								>as opposed to other tools</a
							>).
						</p>
						<p>
							Here it is in all its glory:
							<a
								href="http://danburzo.ro.s3-website-us-east-1.amazonaws.com/assets/streets.svg"
								>streets.svg</a
							>
							<em>(Warning: 262MB file!)</em>
						</p>
						<h2 id="final-thoughts">Final thoughts</h2>
						<p>
							<strong>Making it printable</strong>. Loading or
							converting a 262MB SVG is no easy feat, but
							ImageMagick somehow miraculously created a
							wall-sized PNG image:
						</p>
						<pre><code>convert -density <span>900</span> output/streets<span>.svg</span> output/streets.png
</code></pre>
						<p>
							Another idea worth pursuing is making
							<a href="https://github.com/atom/electron"
								>electron</a
							>
							print out a PDF.
						</p>
						<p>
							<strong>Optimizing the map</strong>. Taking into
							account the output resolution, one could simplify
							the paths with
							<a href="http://mourner.github.io/simplify-js/"
								>simplify.js</a
							>
							to eliminate details without affecting the
							appearance (e.g. points that are very close
							together):
						</p>
						<pre><code>simplify([{x: <span>...</span>, y: <span>...</span> }, { x: <span>...</span>, y: <span>...</span> }, <span>...</span>], <span>0.5</span>) =&gt; [{x : <span>...</span>, y: <span>...</span>}, <span>...</span>]
</code></pre>
						<p>
							And considering the browser needs to build the DOM
							tree along with drawing the millions of paths in our
							file, one easy fix to have fewer DOM nodes is to
							batch the path data into multipaths of, say, a
							thousand paths:
						</p>
						<pre><code>var path_buffer = <span>''</span>;
var counter = <span>0</span>;
<span>...</span>
  path_buffer += path_data;
  <span>if</span> (counter++ &gt; <span>999</span>) {
    this.push(<span>'&lt;path d="'</span> + path_buffer + <span>'" stroke-width="0.1" stroke="black" fill="none"/&gt;\n'</span>);
    counter = <span>0</span>;
    path_buffer = <span>''</span>;
  }
</code></pre>
						<hr />
						<p>
							I hope you’ve enjoyed this short foray into mapping!
							You can find all the scripts discussed here on
							Github:
							<a href="https://github.com/danburzo/every-street"
								>danburzo/every-street</a
							>. If you have any idea on how to make this workflow
							better,
							<a
								href="https://github.com/danburzo/every-street/issues/new"
								>I’d love to hear it</a
							>!
						</p>
					</div>
				</div>
			</div>
		</article>

		<!-- Template to use for page footer -->
		<template class="footer-template">
			<div class="text center">
				<span class="pageNumber"></span>
			</div>
		</template>
	</body>
</html>
